# TERRAFORM



## IaC

* IaC vs Configuration Management
  * CM: OS configuration
  * IaC: Infra deployment
* Infrastructure as Code
  * Collaborative (versioning)
  * Automation friendly


## IaC

* Products
  * CM
    * Ansible
    * Salt
    * Puppet
  * IaC
    * CloudFormation (JSON)
    * Terraform (HCL)
    * Pulumi (Python, Go, TypeScript...)


## What's Terraform

* A tool for managing infrastructure
* Written in Go
* Single binary
* Actively developed
* +36.000 stars on Github 
* Current version 1.3.7 (04/01/2023)
* Stable 1.0 (08/06/2021)


## Why Terraform

* Manage infrastructure lifecycle
* Cloud providers polyglot (not like Cloudformation)
* IaC vs Configuration Management
* Infrastructure as Code
  * Collaborative (versioning)
  * Automation friendly



## Simple workflow

* Write (describe infra)
* Plan (review changes)
* Apply (idempotent changes)



## Files

```
$ tree example-project/
.
+-- main.tf
+-- terraform.tf
+-- versions.tf
+
+-- modules/
|   +-- nestedA/
|   |   +-- vars.tf
|   |   +-- main.tf
|   |   +-- outputs.tf
|   |   +-- versions.tf
```


## HCL

* DSL Hashicorp
* Designed to be easily read and written by humans
* Not JSON/YAML

```
resource "aws_vpc" "main" {
  cidr_block = var.base_cidr_block
}

<BLOCK TYPE> "<BLOCK LABEL>" "<BLOCK LABEL>" {
  # Block body
  <IDENTIFIER> = <EXPRESSION> # Argument
}
```



## Install

* https://www.terraform.io
* New projet directory
```
$ tree tp1-tf/
.
+-- main.tf
+-- terraform.tf
+-- versions.tf
```



## Resources

* Main doc: https://developer.hashicorp.com/
* Registry: https://registry.terraform.io/



## Providers

* Core
  * reading and interpolating config files 
  * state management
  * communication with plugins
* Provider
  * logical abstraction of an upstream API (CRUD)
  * specific by service (AWS, vSphere, ...)
  * official, partner, community


## Provider AWS

* Required config ([docs](https://registry.terraform.io/providers/hashicorp/aws/latest/docstanzu-sdv-qual-legacy-ciphers.ouest-france.fr
  access_key = "*****************"
  secret_key = "*****************"
}
```


## Versions

File **versions.tf**
```
terraform {
  required_providers {
    aws = {
      source = "hashicorp/aws"
      version = "4.53.0"
    }
  }
}
```
See provider doc: [AWS Provider](https://registry.terraform.io/providers/hashicorp/aws/latest)


## Init

* Run in a new or cloned terraform repo
* Download providers and modules
* Create dependency lock file
* Initialize backend (state storage)

```
$ terraform init
```


## Dependency lock file

* Generated by Terraform in .terraform.lock.hcl
* List all the plugins and dependencies required
* Updated each time init is run
* Ensure everyone is using the same plugins and dependencies versions
* Ensure no accidental plugins or dependencies upgrade


## Init

* Create provider and version config
* Add credentials
* Init project



## Define resource

* Resource type
* Internal name
* Arguments and Attributes

```
resource "aws_vpc" "main" {
  cidr_block = "10.0.0.0/16"

  tags = {
    Name = "main"
  }
}
```

* Doc: [resource aws_vpc](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/vpc)


## Plan

* Refresh remote state
* Generate dependency graph
* Display plan summary

```
$ terraform plan
```



## Apply

* Create/update/destroy resources
* Parallelize or serialize changes
* Update state

```
$ terraform apply
```



## Destroy

* Destroy all terraform managed resources

```
$ terraform destroy
```

* Can be targeted to resource 

```
$ terraform destroy -target=aws_subnet.a
```


## Lifecycle

* Create an S3 bucket
  * Resource type: aws_s3_bucket
  * Bucket name: "myname-terraform
  * Apply

* Add Tags
  * environment -> "dev"
  * Apply

* Clean resources
  * Destroy



## State

State file management
* Stored in a JSON state file
* Stores the state file locally by default
* Can also be stored remotely (S3, Consul, Terraform Cloud...)
* Manage only resources in state


## State

Keeping state in sync
* State file is updated every time you run Terraform
* Keep the state file in sync with the actual infrastructure state
* Critical as used to determine what actions to take when you apply changes


## State

State locking
* Prevent simultaneous conflicting changes to the state file
* Lock the state file while one user is making changes
* Prevent other users / CI from making changes until released


## State

State migration
* Init with current storage
* Config new storage
* Launch init with migrate option

```
terraform init -migrate-state
```


## State

State backup
* Versioning or regular back
* If lost or corrupted, manual import or recreation of resources


## State

Commands to edit state
* `terraform pull`: download remote state
* `terraform push`: upload remote state
* `terraform state rm`: remove a resource from state
* `terraform import`: import a resource into state


## S3 / Dynamodb state

* S3 allow backup and versionning
* DynamoDB for state locking

```
terraform {
  backend "s3" {
    bucket         = "terraform-bucket"
    key            = "myproject/terraform.tfstate"
    region         = "eu-west-1"
    encrypt        = true
    dynamodb_table = "terraform-table"
  }
}
```



## Dependency


## Implicit

* Dependency by interpolation


## Implicit

* Be careful of cyclic dependencies

```
resource "aws_security_group" "default" {
  ingress {
    ...
    security_groups = [aws_security_group.admin.id]
  }
}

resource "aws_security_group" "admin" {
  ingress {
    ...
    security_groups = [aws_security_group.default.id]
  }
}
```


## Implicit

* Use independent most specific resource

```
resource "aws_security_group" "default" {
  ingress {
    ...
    security_groups = [aws_security_group.admin.id]
  }
}

resource "aws_security_group" "admin" {
  ingress {
    ...
    security_groups = [aws_security_group.default.id]
  }
}
```



## Explicit

* Using *depends_on* argument

```
resource "aws_s3_bucket" "example" {
  bucket = "terraform_getting_started_guide"
}

resource "aws_instance" "example" {
  ami           = "ami-2757f631"
  instance_type = "t2.micro"

  depends_on = [aws_s3_bucket.example]
}
```



## Interpolation

* Attributes of resources
```
aws_vpc.main.id
```
* Variables
```
var.foo
```
* Functions
```
jsonencode(value)
```



## Input variables

* Must be defined AND assigned
* Defined in *vars.tf* file
```
variable "myip" {}
```
* Assigned in *terraform.tfvars*
```
myip = "192.168.0.10"
```



## Output variables

* Needed to expose module vars
* Defined in *outputs.tf*
```
output "ip" {
  value = aws_eip.ip.public_ip
}
```



## Using modules

* Local source or git repo (use tags)
* Customized vars
* Loaded by **terraform get**

```
module "vpc" {
  source = "./modules/vpc"

  name = "my_vpc"
}
```



## Generalized Type System


### 0.11 Types

* Strings
* Lists of strings (not as module param)
* Maps of strings (not as module param)


### Primitive types

* String
* Number
  * Whole numbers like 15
  * fractional values such as 6.283185
* Bool
  * either true or false
  * can be used in conditional logic


### Conversion of Primitive Types

* **true** converts to **"true"**, and vice-versa
* **false** converts to **"false"**, and vice-versa
* **15** converts to **"15"**, and vice-versa 


### Collection Types

* List
  * sequence of values with number index
* Map
  * collection of values each identified by string label
* Set
  * unique values without any label or ordering


### Type Constraints

```
variable "network" {
  type = string
  default = "Lan_VirtualMachine"
}

variable "netmask" {
  type = number
  default = 16
}

variable "nameserver" {
  type    = list(string)
  default = ["128.1.233.215", "128.1.233.216"]
}
```


### Rich Types

* Modules input/output:
  * Complex types (map, list, etc...)
  * Whole resource (all attributes)



## Iteration constructs


### For each

```
resource "aws_subnet" "subnet" {
  for_each = {
    subnet_a = "192.168.0.0/24"
    subnet_b = "192.168.1.0/24"
  }

  vpc_id     = aws_vpc.main.id
  cidr_block = each.value

  tags = {
    Name = each.key
  }
}

```


### Dynamic Nested Blocks 

```
variable "ingress_ports" {
  type        = list(number)
  default     = [8200, 8201]
}

resource "aws_security_group" "vault" {
  name        = "vault"

  dynamic "ingress" {
    iterator = port
    for_each = var.ingress_ports
    content {
      from_port   = port.value
      to_port     = port.value
    }
  }
}
```



## Data sources


## Existing resources

```
data "aws_vpc" "selected" {
  id = var.vpc_id
}

resource "aws_subnet" "example" {
  vpc_id = data.aws_vpc.selected.id
  ...
}
```
t

## Remote state

```
data "terraform_remote_state" "vpc" {
  backend = "atlas"

  config {
    name = "hashicorp/vpc-prod"
  }
}

resource "aws_instance" "foo" {
  subnet_id = data.terraform_remote_state.vpc.subnet_id
}
```
